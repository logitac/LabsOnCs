## 9. Palindrome Number:
[**Задача -> LeetCode**](https://leetcode.com/problems/palindrome-number/)

### Условие:
Дайте целое число `x`, верните `true` Если `x` является **Палиндромом**, и `false` в противном случае.

**Пример 1:**

**Вход:** x = 121\
**Результат:** true\
**Пояснение:** 121 читается как 121 слева направо и справа налево.

**Пример 2:**

**Вход:** x = -112\
**Результат:** false\
**Пояснение:** Слева направо, это читает -121. Справа налево, это становится 121-. Следовательно, это не палиндром.

**Пример 3:**

**Вход:** x = 10\
**Результат:** false\
**Пояснение:** читает 01 справа налево. Следовательно, это не палиндром.


### Алгоритм решения:
1. Преобразовать число в строку.
2. Создать два указателя: Первый будет указывать на начало строки, другой на конец.
3. Сравнивать каждый символ до того момента, когда они будут не равны.
4. Вернуть false, в ином случае true

Такой способ решения называется: **Стратегией двух указателей**

### Сложность алгоритма
* **Сложность по времени: O(n)**
* **Сложность пространства: O(1)**

##### Решение кодом:
```cs
public class Solution 
{
    public bool IsPalindrome(int x) 
    {
        string strX = x.ToString();
        int left = 0;
        int right = strX.Length - 1;

        while(left <= right)
        {
            if(strX[left] != strX[right])
                return false;

            left++;
            right--;
        }

        return true;
    }
}
```

```
case 1:
x = 121
exit: true
```

`Последующая деятельность: Можете ли вы решить его, не преобразуя целое число в строку?` Отвечая на вопрос, ответ - ДА. Вот алгоритм решения:
> Если бы я немного подумал над задачкой, скорее всего я бы пришёл к такому решению, ведь я в курсе насчёт такого способа переворота числа. Но увы,
> такое решение мне не сразу пришло в голову, что уж говорить, я даже не пытался подумать над ответом на этот вопрос. Будет мне уроком.
### Алгоритм решения:
1. Делаем проверку если число меньше нуля, возвращаем `false` если это так.
2. Создаём две переменные: `original`, `reversed`. `original` инициализируем нашем `x`, а `reversed` нулём.
3. Переворачиваем число. Для этого мы заводим цикл пока `x > 0`.
4. Создаём временную переменную `temp` и инициализируем её последним цифрой числа `x`. Добавляем эту цифру в перевёрнутое число по такой
формуле: `reversed = reversed * 10 + temp`, затем удаляем последнюю цифру.
5. В конце сравниваем `original` с `reversed`

##### Решение кодом:
```cs
public class Solution 
{
    public bool IsPalindrome(int x) 
    {
        if(x < 0)
            return false;
        
        int original = x;
        int reversed = 0;

        while(x > 0)
        {
            int temp = x % 10;
            reversed = reversed * 10 + temp;
            x /= 10;
        }

        return original == reversed;
    }
}
```

```
case 1:
x = 121
exit: true
```

### Сложность алгоритма
* **Сложность по времени: O(n)**
* **Сложность пространства: O(1)**