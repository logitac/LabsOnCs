## 1. Two Sum
[**Задача -> LeetCode**](https://leetcode.com/problems/two-sum/)

### Условие:
Учитывая множество целых чисел `nums` и целое число `target`, возврат индексов двух чисел, чтобы они складывались в `target`.
Вы можете предположить, что каждый вход будет иметь **ровно одно решение**, и вы не можете использовать один и *тот же* элемент дважды.
Вы можете вернуть ответ в любом порядке.

**Пример 1:**

**Вход:** nums = [2,7,11,15], цель = 9\
**Результат:** [0,1]\
**Пояснение:** Потому что nums[0] + nums[1] == 9, мы возвращаемся [0, 1].

**Пример 2:**

**Вход:** цифры = [3,2,4], цель = 6\
**Результат:** [1,2]

**Пример 3:**

**Вход:** цифры = [3,3], мишень = 6\
**Результат:** [0,1]


### Алгоритм решения грубым способом:
1. Перебрать все возможные пары дающие нужную сумму


### Сложность алгоритма

Минус такого решения заключается во **временной сложности** **O(n<sup>2</sup>)** что считается очень медленно.\
**Пространственная сложность: O(1) —** используем только массив из двух элементов.

##### Решение кодом:
```cs
public class Solution 
{
    public int[] TwoSum(int[] nums, int target) 
    {
        for(int i = 0; i < nums.Length; i++) {
            for(int j = i+1; j < nums.Length; j++) {
                if(nums[i] + nums[j] == target) {
                    return new int[] {i, j};
                }
            }
        }

        return new int[0];
    }
}
```

```
case 1:
nums = [2,7,11,15]
target = 7
exit: [0,1]
```

`Последующая деятельность: Можете ли вы придумать алгоритм, который меньше O(n^2) Сложность времени?` Отвечая на вопрос, ответ - ДА. Вот алгоритм решения:
> Такое решение я нашёл на LeetCode во вкладке `Solutions`. Так что таким способ решил не я, а люди, которые умнее меня.
### Алгоритм лучшего решения:
1. Создаём хеш-таблицу (`numMap`), который будет хранить числа и их индексы. Ключ - число, значение - его индекс.
2. Проходим по массиву:
   * i = 0 (число 2):\
   `complement = target - nums[i] = 9 - 2 = 7`\
   Проверяем, если ли 7 в словаре - нет.\
   Добавляем в словарь: {2: 0}
   * i = 1 (число 7):\
   `complement = 9 - 7 = 2`\
   Проверяем, если ли 2 в словаре - ДА! (индекс 0)\
   Возвращаем `[0, 1]`

##### Решение кодом:
```cs
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Dictionary<int, int> numMap = new Dictionary<int, int>();
        for (int i = 0; i < nums.Length; i++) {
            int complement = target - nums[i];
            if (numMap.ContainsKey(complement)) {
                return new int[] { numMap[complement], i };
            }
            numMap[nums[i]] = i;
        }
        return new int[] {};
    }
}
```

```
case 1:
nums = [2,7,11,15]
target = 7
exit: [0,1]
```

### Сложность алгоритма
* **Сложность по времени: O(n)**, что считается наилучшим временем для этой задачки
* **Сложность пространства: O(n)**

