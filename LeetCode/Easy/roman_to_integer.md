## 9. Palindrome Number
[**Задача -> LeetCode**](https://leetcode.com/problems/roman-to-integer/description/)

### Условие:
Условие большое, поэтому расскажу на словах: Перевести римские цифры в число.

**Пример 1:**

**Вход:** s = "III"\
**Результат:** 3\
**Пояснение:** III = 3.

**Пример 2:**

**Вход:** s = "LVIII"\
**Результат:** 58\
**Пояснение:** L= 50, V = 5, III = 3.

**Пример 3:**

**Вход:** s = "MCMXCIV"\
**Результат:** 1994\
**Пояснение:** M = 1000, CM = 900, XC = 90 and IV = 4.


### Алгоритм решения:
1. Создаём словарь (`map`) в котором перечисляем все римские цифры и их значение.
2. Читаем строку и сравниваем текущий элемент со следующим.
3. Если текущий элемент меньше чем следующий, то мы вычитаем текущий элемент с `res`
4. Если больше, то просто прибавляем к `res`.

>Так как в самой задачки есть такое ограничение: "`s` содержит только символы ('I', 'V', 'X', 'L', 'C', 'D', 'M').", 
>то добавление проверки на соответствие символа со словарём `map` не имеет смысла.

### Сложность алгоритма
* **Сложность по времени: O(n)**
* **Сложность пространства: O(1)**

##### Решение кодом:
```cs
public class Solution 
{
    public int RomanToInt(string s) 
    {
        var map = new Dictionary<char, int>
        {
            ['I'] = 1,
            ['V'] = 5,
            ['X'] = 10,
            ['L'] = 50,
            ['C'] = 100,
            ['D'] = 500,
            ['M'] = 1000
        };

        int res = 0;

        for(int i = 0; i < s.Length; i++) {
            if(i < s.Length - 1 && map[s[i]] < map[s[i+1]]) {
                res -= map[s[i]];
            } else {
                res += map[s[i]];
            }
        }

        return res;
    }
}
```

```
case 1:     case 2:       case 3:
s = "III"   s = "LVIII"   s = "MCMXCIV"
exit: 3     exit: 58      exit: 1994
```

> До такого решения я додумался сам. Пришёл я к такому решению не сразу, минут 10-20 я думал, пробовал, 
> пытался в тупую сравнивать, но потом заметил закономерность, что сравнивая текущий и следующий элемент можно
> добавлять и вычитывать результат. `res -= map[s[i]];`. Ну, а использование словаря, было очевидно.
 
> Кстати, моё решение заняло 3 мс, но есть решение, которое занимает 1 мс. Я даже подумать не мог, что использовать 
> if/else в этой ситуации будет быстрее, чем словарь. Как я выяснил, словарь будет быстрее, если элементов 
> в строке или где-то ещё, будет более 1000. Запомню.

##### Решение кодом:
```cs
public class Solution 
{
    public int RomanToInt(string s) 
    {
        int res = 0;
    
        for(int i = 0; i < s.Length; i++)
        {
            if(i < s.Length - 1 && GetValue(s[i]) < GetValue(s[i + 1]))
                res -= GetValue(s[i]);
            else
                res += GetValue(s[i]);
        }
        return res;
    }

    private static int GetValue(char c)
    {
        // Самый быстрый способ - if/else без создания объектов
        if (c == 'I') return 1;
        if (c == 'V') return 5;
        if (c == 'X') return 10;
        if (c == 'L') return 50;
        if (c == 'C') return 100;
        if (c == 'D') return 500;
        if (c == 'M') return 1000;
        return 0;
    }
}
```

> Ну и памяти этот алгоритм будет занимать тоже чуть меньше, чем с созданием словаря.