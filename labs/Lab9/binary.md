## Бинарные файлы. BinaryWriter и BinaryReader

___

Для работы с бинарными файлами предназначена пара классов **BinaryWriter** и **BinaryReader**. 
Эти классы позволяют читать и записывать данные в двоичном формате.

Основные метода класса **BinaryWriter**

* `Close()`: закрывает поток и освобождает ресурсы
* `Flush()`: очищает буфер, дописывая из него оставшиеся данные в файл
* `Seek()`: устанавливает позицию в потоке
* `Write()`: записывает данные в поток

Основные метода класса **BinaryReader**

* `Close()`: закрывает поток и освобождает ресурсы
* `ReadBoolean()`: считывает значение bool и перемещает указатель на один байт
* `ReadByte()`: считывает один байт и перемещает указатель на один байт
* `ReadChar()`: считывает значение char, то есть один символ, и перемещает указатель на столько байтов, сколько занимает символ в текущей кодировке
* `ReadDecimal()`: считывает значение decimal и перемещает указатель на 16 байт
* `ReadDouble()`: считывает значение double и перемещает указатель на 8 байт
* `ReadInt16()`: считывает значение short и перемещает указатель на 2 байта
* `ReadInt32()`: считывает значение int и перемещает указатель на 4 байта
* `ReadInt64()`: считывает значение long и перемещает указатель на 8 байт
* `ReadSingle()`: считывает значение float и перемещает указатель на 4 байта
* `ReadString()`: считывает значение string. Каждая строка предваряется значением длины строки, которое представляет 7-битное целое число

С чтением бинарных данных все просто: соответствующий метод считывает данные определенного типа и перемещает указатель на 
размер этого типа в байтах, например, значение типа **int** занимает 4 байта, поэтому **BinaryReader** считает 4 байта и переместит указать на эти 4 байта.

Посмотрим на реальной задаче применение этих классов. Попробуем с их помощью записывать и считывать из файла массив структур:
```cs
struct State
{
    public string name;
    public string capital;
    public int area;
    public double people;

    public State(string n, string c, int a, double p)
    {
        name = n;
        capital = c;
        people = p;
        area = a;
    }
}

class UsingBinaryWriterAndReader
{
    static void Main()
    {
        State[] states = new State[2];
        states[0] = new State("Германия", "Берлин", 357168, 80.8);
        states[1] = new State("Франция", "Париж", 640679, 64.7);

        string path = @"C:/SomeDir/states.bat";
        try
        {
            using (BinaryWriter bw = new BinaryWriter(File.Open(path, FileMode.OpenOrCreate)))
            {
                foreach (State s in states)
                {
                    bw.Write(s.name);
                    bw.Write(s.capital);
                    bw.Write(s.area);
                    bw.Write(s.people);
                }
            }

            using (BinaryReader br = new BinaryReader(File.Open(path, FileMode.Open)))
            {
                while (br.PeekChar() != -1)
                {
                    string name = br.ReadString();
                    string capital = br.ReadString();
                    int area = br.ReadInt32();
                    double people = br.ReadDouble();

                    Console.WriteLine(
                        "Страна: {0}  столица: {1}  площадь {2} кв. км   численность населения: {3} млн. чел.",
                        name, capital, area, people);
                }
            }
        }
        catch (IOException e)
        {
            Console.WriteLine(e.Message);
        }

    }
}
```
Итак, у нас есть структура **State** с некоторым набором полей. В основной программе создаем массив структур и записываем
с помощью **BinaryWriter**. Этот класс в качестве параметра в конструкторе принимает объект **Stream**, который создается 
вызовом `File.Open(path, FileMode.OpenOrCreate)`.

Затем в цикле пробегаемся по массиву структур и записываем каждое поле структуры в поток. 
В том порядке, в каком эти значения полей записываются, в том порядке они и будут размещаться в файле.

Затем считываем из записанного файла. Конструктор класса **BinaryReader** также в качестве параметра принимает объект потока, 
только в данном случае устанавливаем в качестве режима **_FileMode.Open_**: `new BinaryReader(File.Open(path, FileMode.Open))`

В цикле **while** считываем данные. Чтобы узнать окончание потока, вызываем метод **_PeekChar_**. 
Этот метод считывает следующий символ и возвращает его числовое представление. 
Если символ отсутствует, то метод возвращает `-1`, что будет означать, что мы достигли конца файла.

В цикле последовательно считываем значения поле структур в том же порядке, в каком они записывались.

Таким образом, классы **BinaryWriter** и **BinaryReader** очень удобны для работы с бинарными файлами, 
особенно когда нам известна структура этих файлов. В то же время для хранения и считывания более комплексных объектов, 
например, объектов классов, лучше подходит другое решение - сериализация.
